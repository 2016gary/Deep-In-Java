# JVM入门教程
### By Gary

# 1.编译型语言&解释型语言
### 首先，我们编程都是用的高级语言(写汇编和机器语言的大牛们除外)，计算机不能直接理解高级语言，只能理解和运行机器语言，所以必须要把高级语言翻译成机器语言，计算机才能运行高级语言所编写的程序。
## 1.1 编译型语言：
### 用编译型语言写的程序执行之前，需要一个专门的编译过程，通过编译系统（不仅仅只是通过编译器，编译器只是编译系统的一部分）把高级语言翻译成机器语言，把源高级程序编译成为机器语言文件，以后就可以直接运行而不需要编译了，因为翻译只做了一次，运行时不需要翻译，所以编译型语言的程序执行效率高，但也不能一概而论，部分解释型语言的解释器通过在运行时动态优化代码，甚至能够使解释型语言的性能超过编译型语言。
## 1.2 解释型语言：
### 解释型语言编写的程序不需要编译。解释型语言在运行的时候才翻译，在执行的时候，专门有一个解释器能够将语言翻译成机器语言，每个语句都是执行的时候才翻译。这样解释型语言每执行一次就要翻译一次，效率比较低。	
## 1.3 Java语言：
### Java的做法是找到编译型语言和解释性语言的一个中间点：
- Java代码会被编译：被编译成Java字节码，而不是针对某种CPU的二进制代码。
- Java代码会被解释：Java字节码需要被java程序解释执行，此时，Java字节码被翻译成CPU相关的二进制代码。
- JIT编译器的作用：在程序运行期间，将Java字节码编译成平台相关的二进制代码。正因为此编译行为发生在程序运行期间，所以该编译器被称为Just-In-Time编译器。

<img src="./Images/java_process1.png" width="80%" alt="无法显示该图片"/>

<img src="./Images/java_process2.png" width="70%" alt="无法显示该图片"/>

## 1.4 Java代码编译和执行的整个过程
### Java代码编译是由Java源码编译器来完成：

<img src="./Images/java_c.gif" width="70%" alt="无法显示该图片"/>

### Java字节码的执行是由JVM执行引擎来完成：

<img src="./Images/java_e.gif" width="70%" alt="无法显示该图片"/>

# 2.class字节码文件
### 计算机只能识别0和1，所以编写的程序都需要经过编译器，转换为由0和1组成的二进制本地机器码(Native Code)，.class文件也是0，1二进制程序。

<img src="./Images/Jvm_class_loading.png" alt="无法显示该图片"/>

## 2.1 class字节码文件结构：
### 一个class字节码文件是由一个ClassFile结构组成：

<img src="./Images/classfile.png" alt="无法显示该图片"/>

### 2.1.1 魔数
### 每个Class文件头4个字节称为魔数(Magic Number),作用是用于确定这个Class文件是否能被虚拟机所接受，魔数固定值0xCAFEBABE。这是身份识别，比如jpeg等图片文件头也会有魔数。
### 2.1.2 版本号
### 紧跟魔数，也占用4个字节。从第5字节到第8字节存储的分别是次版本号，主版本号。
### 常量池

# 3.JVM
### Java1.8已经完全移除了永久代，原来永久代存放的内容一部分放在了堆，一部分放在了元空间（Metaspace），元空间是Java1.8新增的一块区间。



















# 4.内存泄漏和内存溢出
## 4.1 内存泄漏
### 内存泄漏是指那些本应该回收（不再使用）的内存对象无法被系统回收的现象。因为垃圾回收机制不能完全保证内存对象在该释放的地方释放，现代java虚拟机中普遍使用根集算法去计算对象的引用可达性，不可达的才能回收，例如下图中的无用对象被有用对象引用着，导致无用对象引用一直可达，系统回收器不敢冒然回收，从而造成内存泄漏。内存泄露是一种状态描述。

<img src="./Images/OOM1.png" alt="无法显示该图片"/>

## 4.2 内存溢出
### 系统在为某段执行指令（程序）分配内存的时候，发现内存不足，抛出错误，这叫做内存溢出。内存溢出是一种结果描述。通常都是由于内存泄露从而引发内存溢出。

<img src="./Images/OOM2.png" alt="无法显示该图片"/>






